# Get the layer names and number of weights per layer
layer_names = [name for name in model.state_dict().keys() if 'weight' in name]
num_weights_per_layer = {name: model.state_dict()[name].numel() for name in layer_names}

# Function to inject a single bit-flip fault in a floating-point number
def bit_flip(value):
    cpu_value = value.cpu().item()
    int_value = np.float32(cpu_value).view(np.int32)
    bit_to_flip = 1 << random.randint(0, 31)
    corrupted_int = int_value ^ bit_to_flip
    corrupted_value = np.int32(corrupted_int).view(np.float32)
    return torch.tensor(corrupted_value).to(value.device)


# Function to inject faults in the model's weights
def inject_faults_in_weights(model, no_faults):
    
    state_dict = model.state_dict()
    for _ in range (no_faults):
        layer = random.choice(layer_names)
        idx = random.randint(0, num_weights_per_layer[layer] - 1)
        weight = state_dict[layer].view(-1).to('cuda')
        weight[idx] = bit_flip(weight[idx])
    model.load_state_dict(state_dict)

def evaluate_accuracy(model, val_loader):
    correct, total = 0, 0

    with torch.no_grad():
        for inputs, labels in val_loader:
            inputs, labels = inputs.to('cuda'), labels.to('cuda')
            outputs = model(inputs)
            _, predicted = torch.max(outputs, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

    val_accuracy = 100 * correct / total
    print(f"Validation Accuracy: {val_accuracy:.2f}%")
    return val_accuracy

def reliability_assessment(model, val_loader, fault_rate):
    
    model.load_state_dict(torch.load(checkpoint_path, map_location=device))
    # Inject faults into the model's weights
    inject_faults_in_weights(model, no_faults)

    # Evaluate accuracy after fault injection
    corrupted_accuracy = evaluate_accuracy(model, val_loader)
    print(f'Accuracy after injecting faults (fault rate {fault_rate}%): {corrupted_accuracy:.2f}%')
    return corrupted_accuracy


n = 0
for _ in layer_names:
  n = n + num_weights_per_layer[_]
print("no. weights: ",n)
repetitions = 50
ber = 0.0000005  
no_faults = int(ber * n)
print("no. faults: ", no_faults)
drop = []
# print(model)
original_accuracy = evaluate_accuracy(model, val_loader)
print(f'Original Model Accuracy: {original_accuracy:.2f}%')
for i in range (repetitions):
    faulty_acc = reliability_assessment(model, val_loader, no_faults)
    drop.append(original_accuracy - faulty_acc)
avg_drop = sum(drop)/len(drop)
print(f'average accuracy drop at BER {ber} is {avg_drop}')